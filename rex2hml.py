#!/usr/bin/env python3
# this is from Zac's tools collection.

"""Convert Rosette /entities ADM JSON results to human readable HTML

Entity mentions are marked as bold and mention metadata is viewable in a
tooltip on mouseover.

Given a path to a .adm.json file, HTML is written to stdout.
"""

import codecs
import json
import re
import sys

from html import escape

COLOR = {
    'LOCATION': 'SlateBlue',
    'NATIONALITY': 'LightBlue',
    'ORGANIZATION': 'LightGreen',
    'PERSON': 'Coral',
    'TITLE': 'Pink',
    'PRODUCT': 'LightOrange'
}

IDENTITY_COLORS = [
    'Black',
    'Navy',
    'Blue',
    'Green',
    'Teal',
    'Lime',
    'Aqua',
    'Cyan',
    'Turquoise',
    'Purple',
    'Olive',
    'Gray',
    'Brown',
    'Silver',
    'Tan',
    'Plum',
    'Violet',
    'Beige',
    'Coral',
    'Pink',
    'Yellow',
    'LightYellow',
    'Indigo',
]

def load(filename):
    try:
        with open(filename, mode='r') as f:
            return json.load(f)
    except Exception as e:
        print('file:', filename, file=sys.stderr)
        print(e, file=sys.stderr)

def extent(obj):
    """Get the start and end offset attributes of a dict-like object

    a = {'startOffset': 0, 'endOffset': 5}
    b = {'startOffset': 0, 'endOffset': 10}
    c = {'startOffset': 5, 'endOffset': 10}

    extent(a) -> (0, 5)
    extent(b) -> (0, 10)
    extent(c) -> (5, 10)
    extent({}) -> (-1, -1)

    """
    return obj.get('startOffset', -1), obj.get('endOffset', -1)

def get_text(string, start, end, bom=True):
    """This method correctly accesses slices of strings using character
    start/end offsets referring to UTF-16 encoded bytes.  This allows
    for using character offsets generated by Rosette (and other softwares)
    that use UTF-16 native string representations under Pythons with UCS-4 
    support, such as Python 3.3+ (refer to https://www.python.org/dev/peps/pep-0393/).
    
    The offsets are adjusted to account for a UTF-16 byte order mark (BOM) 
    (2 bytes) and also that each UTF-16 logical character consumes 2 bytes.
    'character' in this context refers to logical characters for the purpose of
    character offsets; an individula character can consume up to 4 bytes (32 
    bits for so-called 'wide' characters) and graphemes can consume even more.
    """
    if not isinstance(string, str):
        raise ValueError('expected string to be of type str')
    if not any(((start is None), isinstance(start, int))):
        raise ValueError('expected start to be of type int or NoneType')
    if not any(((end is None), isinstance(end, int))):
        raise ValueError('expected end to be of type int or NoneType')
    if start is not None:
        start *= 2
        if bom:
            start += 2
    if end is not None:
        end *= 2
        if bom:
            end += 2
    utf_16, _ = codecs.utf_16_encode(string)
    sliced, _ = codecs.utf_16_decode(utf_16[start:end])
    return sliced

def mentions(adm, color='type'):
    """Generate mentions with augmented metadata from an ADM"""
    # Check if there are enough colors to give each entity a unique color
    ids = [e['entityId'] for e in adm['attributes']['entities']['items']]
    if len(ids) > len(IDENTITY_COLORS):
        print(
            (
                f'[WARNING]: There were {len(ids)} distinct entities in the '
                f'document but only {len(IDENTITY_COLORS)} colors available. '
                f'Some colors were reused!'
            ),
            file=sys.stderr
        )
    # Augment each mention with metadata
    identity_colors = {}
    for entity in adm['attributes']['entities']['items']:
        id_ = entity['entityId']
        index = ids.index(id_) % len(IDENTITY_COLORS)
        identity_colors[id_] = IDENTITY_COLORS[index]
        for i, mention in enumerate(entity['mentions'], 1):
            mention['entityId'] = entity.get('entityId')
            mention['index'] = '{}-{}'.format(entity.get('entityId'), i)
            mention['type'] = entity['type']
            start, end = extent(mention)
            mention['text'] = get_text(adm['data'], start, end)
            mention['color'] = get_color(mention, identity_colors, color=color)
            yield mention

def get_color(mention, identity_colors, color='type'):
    if color == 'type':
        return COLOR.get(mention['type'], 'Gray')
    elif color == 'identity':
        return identity_colors.get(mention.get('entityId'), 'Gray')
    return 'Gray'

def tag(mention):
    """Create an HTML mark (with tooltip) for the given mention"""
    info = '<br>'.join(
        json.dumps(mention, ensure_ascii=False, indent=2).split('\n')
    )
    return ((
        '<mark class="wrapper" entity="{}" id="{}" style="background-color: {}">'
        '{}'
        '<div class="tooltip">{}</div>'
        '</mark>'
    )).format(
        mention['type'] if len(mention['type']) <= len(mention['text']) else mention['type'][:3],
        mention['index'],
        mention['color'],
        htmlify(mention['text']),
        info
    )

def htmlify(s):
    """HTML escape a string and replace newlines with <br> tags"""
    br = re.compile(r'\n+')
    return br.sub('<br>', escape(s))

def chunk(adm, color):
    """Split ADM into chunks of HTML
    
    A chunk is a span of text between entity mentions or the span of a
    mention itself.  Chunks for mentions will have HTML spans with tooltip
    divs inserted."""
    items = sorted(mentions(adm, color=color), key=extent)
    if not any(items):
        return [adm['data']]
    first = items[0]
    start, end = extent(first)
    chunks = [htmlify(get_text(adm['data'], None, start)), tag(first)]
    cursor = end
    for mention in items[1:]:
        start, end = extent(mention)
        chunks.append(htmlify(get_text(adm['data'], cursor, start)))
        chunks.append(tag(mention))
        cursor = end
    chunks.append(get_text(adm['data'], cursor, None))
    return chunks

def html(adm, color):
    """Synthesize an HTML document from an ADM"""
    content = ''.join(chunk(adm, color))
    pre = '''
<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8"/>
    <style>
    .content {
        margin: 300px 100px 10px 100px;
        padding: 20px 20px 20px 20px;
    }
    
    [entity] {
        line-height: 1;
        display: inline-block;
        border-radius: .25em;
    }
    
    [entity]:before {
        content: attr(entity);
        font-size: .55em;
        line-height: 1;
        text-transform: uppercase;
        display: block;
        text-align: center;
        font-weight: bolder;
        padding-top: .1rem;
    }
    
    .wrapper {
      color: #blue;
      cursor: help;
      position: relative;
      -webkit-transform: translateZ(0); /* webkit flicker fix */
      -webkit-font-smoothing: antialiased; /* webkit text rendering fix */
    }
    
    .wrapper .tooltip {
      background: #1496bb;
      bottom: 100%;
      color: #fff;
      display: inline-block;
      left: -25px;
      margin: 15px;
      opacity: 0;
      padding: 20px;
      pointer-events: none;
      font-family: monospace;
      width: auto;
      white-space: pre-wrap;
      -webkit-transform: translateY(10px);
         -moz-transform: translateY(10px);
          -ms-transform: translateY(10px);
           -o-transform: translateY(10px);
              transform: translateY(10px);
      -webkit-transition: all .25s ease-out;
         -moz-transition: all .25s ease-out;
          -ms-transition: all .25s ease-out;
           -o-transition: all .25s ease-out;
              transition: all .25s ease-out;
      -webkit-box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.28);
         -moz-box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.28);
          -ms-box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.28);
           -o-box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.28);
              box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.28);
    }
    
    .tooltip {
        position: absolute;
    }
    
    .wrapper .tooltip:before {
      bottom: -20px;
      content: " ";
      display: block;
      height: 20px;
      left: 0;
      position: absolute;
    }  
    
    .wrapper:hover .tooltip {
      opacity: 1;
      pointer-events: auto;
      -webkit-transform: translateY(0px);
         -moz-transform: translateY(0px);
          -ms-transform: translateY(0px);
           -o-transform: translateY(0px);
              transform: translateY(0px);
    }
    </style>
    <head>
    <body>
    <div class="content">'''
    post = '''
    </div>
    </body>
</html>'''
    return pre + content + post

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description=__doc__
    )
    parser.add_argument(
        'input',
        help='path to an ADM JSON file with .attributes.entities.items'
    )
    parser.add_argument(
        '-s', '--color-style',
        default='type',
        choices=['identity', 'type'],
        help=(
            'the style for coloring entities (by entity identity or by '
            'entity type)'
        )
    )
    parser.add_argument(
        '-c', '--color-values',
        default=[],
        nargs='+',
        help='list of HTML colors (either hex values or color names)'
    )
    args = parser.parse_args()
    IDENTITY_COLORS = args.color_values or IDENTITY_COLORS
    print(html(load(args.input), args.color_style))
